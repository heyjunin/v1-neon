# Testing Rules

## Test Structure
- Use the established testing patterns with Jest and React Testing Library
- Follow the component structure for test files
- Implement proper TypeScript interfaces for test data

## Test File Structure
```typescript
// Component test template
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ComponentName } from './ComponentName';

// Mock dependencies
vi.mock('@v1/trpc/react', () => ({
  useQuery: vi.fn(),
  useMutation: vi.fn(),
}));

describe('ComponentName', () => {
  const mockProps = {
    // Define mock props
  };

  beforeEach(() => {
    // Reset mocks before each test
    vi.clearAllMocks();
  });

  it('renders correctly', () => {
    render(<ComponentName {...mockProps} />);
    
    expect(screen.getByText('Expected Text')).toBeInTheDocument();
  });

  it('handles user interactions', async () => {
    const mockOnClick = vi.fn();
    render(<ComponentName {...mockProps} onClick={mockOnClick} />);
    
    const button = screen.getByRole('button');
    fireEvent.click(button);
    
    expect(mockOnClick).toHaveBeenCalledTimes(1);
  });

  it('displays loading state', () => {
    render(<ComponentName {...mockProps} isLoading={true} />);
    
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });

  it('displays error state', () => {
    render(<ComponentName {...mockProps} error="Test error" />);
    
    expect(screen.getByText('Test error')).toBeInTheDocument();
  });
});
```

## tRPC Testing
```typescript
// Test tRPC procedures
import { createTRPCMsw } from 'msw-trpc';
import { http, HttpResponse } from 'msw';
import { trpc } from '@v1/trpc/react';

const trpcMsw = createTRPCMsw(trpc);

describe('tRPC Procedures', () => {
  it('fetches data successfully', async () => {
    const mockData = [
      { id: '1', name: 'Test Item' },
      { id: '2', name: 'Test Item 2' },
    ];

    server.use(
      trpcMsw.query('getItems', {
        status: 200,
        body: mockData,
      })
    );

    const { result } = renderHook(() => useQuery(['getItems']), {
      wrapper: ({ children }) => (
        <QueryClient client={queryClient}>{children}</QueryClient>
      ),
    });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toEqual(mockData);
  });

  it('handles mutation errors', async () => {
    server.use(
      trpcMsw.mutation('createItem', {
        status: 400,
        body: { error: 'Validation failed' },
      })
    );

    const { result } = renderHook(() => useMutation(['createItem']), {
      wrapper: ({ children }) => (
        <QueryClient client={queryClient}>{children}</QueryClient>
      ),
    });

    result.current.mutate({ name: 'Test' });

    await waitFor(() => {
      expect(result.current.isError).toBe(true);
    });

    expect(result.current.error?.message).toBe('Validation failed');
  });
});
```

## API Route Testing
```typescript
// Test API routes
import { createMocks } from 'node-mocks-http';
import { GET, POST } from './route';

describe('API Route', () => {
  it('handles GET request', async () => {
    const { req, res } = createMocks({
      method: 'GET',
      query: { search: 'test' },
    });

    await GET(req);

    expect(res._getStatusCode()).toBe(200);
    expect(JSON.parse(res._getData())).toEqual({
      success: true,
      data: expect.any(Array),
    });
  });

  it('handles POST request', async () => {
    const { req, res } = createMocks({
      method: 'POST',
      body: { name: 'Test Item' },
    });

    await POST(req);

    expect(res._getStatusCode()).toBe(201);
    expect(JSON.parse(res._getData())).toEqual({
      success: true,
      data: expect.objectContaining({
        id: expect.any(String),
        name: 'Test Item',
      }),
    });
  });

  it('handles validation errors', async () => {
    const { req, res } = createMocks({
      method: 'POST',
      body: { name: '' }, // Invalid data
    });

    await POST(req);

    expect(res._getStatusCode()).toBe(400);
    expect(JSON.parse(res._getData())).toEqual({
      error: 'Validation failed',
      details: expect.any(Array),
    });
  });
});
```

## Database Testing
```typescript
// Test database operations
import { db } from '@v1/database/drizzle';
import { users } from '@v1/database/schema/users';

describe('Database Operations', () => {
  beforeEach(async () => {
    // Clean up database before each test
    await db.delete(users);
  });

  it('creates user successfully', async () => {
    const userData = {
      email: 'test@example.com',
      fullName: 'Test User',
    };

    const result = await db.insert(users).values(userData).returning();

    expect(result).toHaveLength(1);
    expect(result[0]).toMatchObject({
      email: userData.email,
      fullName: userData.fullName,
    });
  });

  it('handles unique constraint violations', async () => {
    const userData = {
      email: 'test@example.com',
      fullName: 'Test User',
    };

    // Insert first user
    await db.insert(users).values(userData);

    // Try to insert duplicate
    await expect(
      db.insert(users).values(userData)
    ).rejects.toThrow();
  });
});
```

## Component Integration Testing
```typescript
// Test component integration
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ComponentWithData } from './ComponentWithData';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: { retry: false },
    mutations: { retry: false },
  },
});

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryClientProvider client={queryClient}>
    {children}
  </QueryClientProvider>
);

describe('ComponentWithData', () => {
  it('loads and displays data', async () => {
    render(<ComponentWithData />, { wrapper });

    // Check loading state
    expect(screen.getByText('Loading...')).toBeInTheDocument();

    // Wait for data to load
    await waitFor(() => {
      expect(screen.getByText('Test Item')).toBeInTheDocument();
    });

    // Check that loading state is gone
    expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
  });

  it('handles form submission', async () => {
    render(<ComponentWithData />, { wrapper });

    // Fill form
    fireEvent.change(screen.getByLabelText('Name'), {
      target: { value: 'New Item' },
    });

    // Submit form
    fireEvent.click(screen.getByRole('button', { name: 'Submit' }));

    // Wait for submission to complete
    await waitFor(() => {
      expect(screen.getByText('Success!')).toBeInTheDocument();
    });
  });
});
```

## Mocking Strategies
```typescript
// Implement proper mocking strategies
import { vi } from 'vitest';

// Mock external dependencies
vi.mock('@v1/logger', () => ({
  logger: {
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
  },
}));

vi.mock('@v1/database/adapters', () => ({
  createDatabaseAdapter: vi.fn(() => ({
    getUser: vi.fn(),
    createUser: vi.fn(),
    updateUser: vi.fn(),
  })),
}));

// Mock environment variables
vi.mock('@v1/env', () => ({
  env: {
    DATABASE_URL: 'test-database-url',
    NODE_ENV: 'test',
  },
}));

// Mock Next.js functions
vi.mock('next/navigation', () => ({
  useRouter: () => ({
    push: vi.fn(),
    replace: vi.fn(),
    back: vi.fn(),
  }),
  useSearchParams: () => new URLSearchParams(),
}));
```

## Test Utilities
```typescript
// Create test utilities
export const createMockUser = (overrides = {}) => ({
  id: 'test-user-id',
  email: 'test@example.com',
  fullName: 'Test User',
  avatarUrl: 'https://example.com/avatar.jpg',
  createdAt: new Date(),
  updatedAt: new Date(),
  ...overrides,
});

export const createMockPost = (overrides = {}) => ({
  id: 'test-post-id',
  title: 'Test Post',
  content: 'Test content',
  slug: 'test-post',
  status: 'published' as const,
  authorId: 'test-user-id',
  createdAt: new Date(),
  updatedAt: new Date(),
  ...overrides,
});

export const renderWithProviders = (
  ui: React.ReactElement,
  options = {}
) => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return render(ui, {
    wrapper: ({ children }) => (
      <QueryClientProvider client={queryClient}>
        <ThemeProvider>
          {children}
        </ThemeProvider>
      </QueryClientProvider>
    ),
    ...options,
  });
};
```

## File Structure
```
__tests__/
├── components/
│   ├── ComponentName.test.tsx   # Component tests
│   └── __mocks__/               # Component mocks
├── api/
│   └── route.test.ts            # API route tests
├── utils/
│   ├── test-utils.ts            # Test utilities
│   └── mocks.ts                 # Mock data
└── integration/
    └── user-flow.test.tsx       # Integration tests

tests/
├── unit/                        # Unit tests
├── integration/                 # Integration tests
└── e2e/                         # End-to-end tests
```

## Best Practices
- Write tests for all critical functionality
- Use descriptive test names
- Test both success and error scenarios
- Mock external dependencies
- Use proper test isolation
- Implement proper cleanup
- Use TypeScript for test files
- Follow the established patterns
- Test accessibility features
- Test edge cases

## Testing Commands
```bash
# Run all tests
bun test

# Run tests in watch mode
bun test --watch

# Run tests with coverage
bun test --coverage

# Run specific test file
bun test ComponentName.test.tsx

# Run tests matching pattern
bun test --grep "user flow"

# Run tests in specific environment
NODE_ENV=test bun test
```
description:
globs:
alwaysApply: false
---
